# -*- coding: utf-8 -*-
"""DEC_Slab_App

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1kHJymvJpQRclZ6ilEQ5IlADn5BwsojRr
"""

import math

# ==========================================
# PART 1: THE DATA BANK
# ==========================================

# 1. Short Span Coefficients (Beta_sx)
COEFF_DATA_SHORT = {
    1.0: [0.024, 0.028, 0.028, 0.033, 0.032, 0.033, 0.040, 0.038, 0.048],
    1.1: [0.028, 0.032, 0.032, 0.037, 0.035, 0.040, 0.046, 0.043, 0.056],
    1.2: [0.033, 0.036, 0.037, 0.042, 0.039, 0.047, 0.052, 0.048, 0.064],
    1.3: [0.036, 0.039, 0.041, 0.046, 0.043, 0.053, 0.057, 0.052, 0.071],
    1.4: [0.039, 0.042, 0.044, 0.050, 0.045, 0.059, 0.062, 0.056, 0.077],
    1.5: [0.041, 0.045, 0.048, 0.053, 0.048, 0.064, 0.066, 0.059, 0.083],
    1.75: [0.045, 0.049, 0.055, 0.059, 0.052, 0.073, 0.075, 0.065, 0.093],
    2.0: [0.048, 0.052, 0.063, 0.065, 0.055, 0.082, 0.083, 0.070, 0.103]
}

# 2. Long Span Coefficients (Beta_sy)
COEFF_DATA_LONG = [0.024, 0.024, 0.028, 0.028, 0.024, 0.033, 0.033, 0.028, 0.048]

PANEL_TYPES = [
    "Interior Panel",
    "One Short Edge Discontinuous",
    "One Long Edge Discontinuous",
    "Two Adjacent Edges Discontinuous",
    "Two Short Edges Discontinuous",
    "Two Long Edges Discontinuous",
    "Three Edges Discontinuous (1 Long Cont)",
    "Three Edges Discontinuous (1 Short Cont)",
    "Four Edges Discontinuous"
]

# 3. Standard Bar Areas
BAR_AREAS_SINGLE = {8: 50.3, 10: 78.5, 12: 113.1, 16: 201.1, 20: 314.2}
STANDARD_SPACINGS = [75, 100, 125, 150, 175, 200, 250, 300]


# ==========================================
# PART 2: LOGIC FUNCTIONS
# ==========================================

def get_short_coefficient(ratio, panel_index):
    """Interpolates Beta_sx based on ratio"""
    ratio = min(ratio, 2.0)
    table_ratios = sorted(COEFF_DATA_SHORT.keys())

    if ratio in COEFF_DATA_SHORT:
        return COEFF_DATA_SHORT[ratio][panel_index]

    lower_r = max([r for r in table_ratios if r < ratio])
    upper_r = min([r for r in table_ratios if r > ratio])

    lower_val = COEFF_DATA_SHORT[lower_r][panel_index]
    upper_val = COEFF_DATA_SHORT[upper_r][panel_index]

    interpolated = lower_val + (ratio - lower_r) * (upper_val - lower_val) / (upper_r - lower_r)
    return round(interpolated, 4)

def check_edge_continuity(panel_index, direction):
    """Returns True if the edge is Continuous, False if Discontinuous"""
    p_name = PANEL_TYPES[panel_index]

    if direction == "Short Span Support":
        if p_name in ["Two Long Edges Discontinuous", "Four Edges Discontinuous", "Three Edges Discontinuous (1 Short Cont)"]:
            return False

    if direction == "Long Span Support":
        if p_name in ["Two Short Edges Discontinuous", "Four Edges Discontinuous", "Three Edges Discontinuous (1 Long Cont)"]:
            return False

    return True

def get_bar_provision_details(as_required, bar_dia):
    """Returns dictionary with text and numeric data"""
    area_one_bar = BAR_AREAS_SINGLE[bar_dia]
    selected_spacing = 0
    area_provided_val = 0

    for spacing in reversed(STANDARD_SPACINGS):
        area_provided = (1000 / spacing) * area_one_bar
        if area_provided >= as_required:
            selected_spacing = spacing
            area_provided_val = area_provided
            break

    if selected_spacing == 0:
        return {"text": "FAIL: Increase Bar Size", "area_prov": 0, "spacing": 0}
    else:
        return {
            "text": f"Provide Y{bar_dia} @ {selected_spacing}mm c/c",
            "area_prov": area_provided_val,
            "spacing": selected_spacing
        }

def check_deflection(Lx, d, fck, As_req, As_prov, panel_index):
    """EC2 Clause 7.4.1 Check"""
    if As_req <= 0: return {"status": "N/A", "actual": 0, "allowable": 0, "K": 0}

    # 1. Structural System Factor (K)
    p_name = PANEL_TYPES[panel_index]
    if p_name == "Four Edges Discontinuous":
        K = 1.0
    elif p_name == "Interior Panel":
        K = 1.5
    else:
        K = 1.3

    # 2. Reinforcement Ratio
    rho = As_req / (1000 * d)
    rho_0 = math.sqrt(fck) * 0.001

    # 3. Basic L/d Ratio
    if rho <= rho_0:
        basic_ratio = K * (11 + 1.5 * math.sqrt(fck) * (rho_0/rho))
    else:
        basic_ratio = K * (11 + 1.5 * math.sqrt(fck) * (rho_0/rho) + 3.2 * math.sqrt(fck) * ((rho_0/rho) - 1)**1.5)

    # 4. Modification Factor
    # Limit to 1.5 per EC2 simplified guidance
    factor = min(1.5, (500/460) * (As_prov / As_req))

    allowable_ratio = basic_ratio * factor

    if Lx > 7000:
        allowable_ratio *= (7000/Lx)

    actual_ratio = Lx / d
    status = "PASS" if actual_ratio <= allowable_ratio else "FAIL"

    return {"actual": round(actual_ratio, 2), "allowable": round(allowable_ratio, 2), "status": status, "K": K}

def check_shear(n, Lx, d, fck, As_prov, panel_index):
    """
    EC2 Clause 6.2 Standard Shear Check (no shear reinforcement)
    V_Ed vs V_Rd,c
    """
    # 1. Calculate Design Shear Force (V_Ed) at support
    # Simplified method: Shear is highest at continuous edge (~0.5 * Load * Span)
    # Some designers use coefficients (e.g., 0.6 for continuous), but 0.5 is standard simplified.
    V_Ed = 0.5 * n * (Lx / 1000) # Result in kN

    # 2. Calculate Concrete Shear Capacity (V_Rd,c)
    # k = 1 + sqrt(200/d) <= 2.0
    k = 1 + math.sqrt(200 / d)
    k = min(k, 2.0)

    # Reinforcement ratio (rho_l) <= 0.02
    # We use the provided steel at the support (or midspan if determining general capacity)
    # Using As_prov from the calculation is safe.
    rho_l = As_prov / (1000 * d)
    rho_l = min(rho_l, 0.02)

    # V_Rd,c Formula [Eq 6.2.a]
    # C_Rd,c = 0.18 / gamma_c (1.5) = 0.12
    # v_min = 0.035 * k^1.5 * fck^0.5

    C_Rdc = 0.18 / 1.5

    # Term 1
    val_1 = C_Rdc * k * (100 * rho_l * fck)**(1/3)

    # Minimum Shear Capacity check
    v_min = 0.035 * (k**1.5) * (fck**0.5)

    design_shear_stress = max(val_1, v_min)

    # Total Resistance V_Rd,c = stress * b * d
    # Note: d is in mm, b is 1000mm. Result is in Newtons. Divide by 1000 for kN.
    V_Rdc = design_shear_stress * 1000 * d / 1000

    status = "PASS" if V_Ed <= V_Rdc else "FAIL"

    return {
        "V_Ed": round(V_Ed, 2),
        "V_Rdc": round(V_Rdc, 2),
        "status": status,
        "utilization": round(V_Ed/V_Rdc, 2)
    }


# ==========================================
# PART 3: THE MAIN CALCULATION
# ==========================================

def run_design(Lx, Ly, h, fck, fyk, cover, Gk, Qk, bar_dia, panel_type_index):

    print(f"\n{'='*60}")
    print(f"EUROCODE 2 SLAB DESIGN REPORT")
    print(f"Panel: {Lx}mm x {Ly}mm | Type: {PANEL_TYPES[panel_type_index]}")
    print(f"{'='*60}\n")

    ratio = round(Ly/Lx, 2)
    n = 1.35*Gk + 1.5*Qk

    # --- 1. GET COEFFICIENTS ---
    Bsx_mid = get_short_coefficient(ratio, panel_type_index)
    Bsy_mid = COEFF_DATA_LONG[panel_type_index]

    Bsx_sup = 1.33 * Bsx_mid if check_edge_continuity(panel_type_index, "Short Span Support") else 0.0
    Bsy_sup = 1.33 * Bsy_mid if check_edge_continuity(panel_type_index, "Long Span Support") else 0.0

    # --- 2. CALCULATE MOMENTS ---
    Msx_mid = Bsx_mid * n * (Lx/1000)**2
    Msy_mid = Bsy_mid * n * (Lx/1000)**2
    Msx_sup = Bsx_sup * n * (Lx/1000)**2
    Msy_sup = Bsy_sup * n * (Lx/1000)**2

    # --- 3. CALCULATE STEEL AREAS ---
    dx = h - cover - (bar_dia/2)
    dy = h - cover - bar_dia - (bar_dia/2)
    fctm = 0.3 * (fck**(2/3))
    As_min = max(0.26 * (fctm/fyk) * 1000 * dx, 0.0013 * 1000 * dx)

    def calc_As_and_Prov(M_val, eff_d):
        if M_val == 0:
            return 0, 0, {"text": "Min Steel Only", "area_prov": As_min} # Default to As_min for check

        K = (M_val * 10**6) / (1000 * eff_d**2 * fck)
        if K > 0.167: return 9999, 0, {"text": "FAIL (K>0.167)", "area_prov": 0}

        z = eff_d * (0.5 + math.sqrt(0.25 - K/1.134))
        z = min(z, 0.95*eff_d)
        req = (M_val * 10**6) / (0.87 * fyk * z)

        target = max(req, As_min)
        prov_details = get_bar_provision_details(target, bar_dia)

        return req, target, prov_details

    # Calculate All Areas
    req_sx, targ_sx, prov_sx = calc_As_and_Prov(Msx_mid, dx)
    req_sy, targ_sy, prov_sy = calc_As_and_Prov(Msy_mid, dy)
    req_sx_sup, targ_sx_sup, prov_sx_sup = calc_As_and_Prov(Msx_sup, dx)
    req_sy_sup, targ_sy_sup, prov_sy_sup = calc_As_and_Prov(Msy_sup, dy)

    # --- 4. PRINT REINFORCEMENT SCHEDULE ---
    print(f"{'Location':<15} | {'Role':<10} | {'Area (Req/Min)':<15} | {'Provision'}")
    print("-" * 75)

    # Midspan
    if targ_sx >= targ_sy:
        print(f"{'Midspan':<15} | {'MAIN':<10} | {int(targ_sx):<15} | {prov_sx['text']}")
        print(f"{'Midspan':<15} | {'SEC':<10} | {int(targ_sy):<15} | {prov_sy['text']}")
    else:
        print(f"{'Midspan':<15} | {'MAIN':<10} | {int(targ_sy):<15} | {prov_sy['text']}")
        print(f"{'Midspan':<15} | {'SEC':<10} | {int(targ_sx):<15} | {prov_sx['text']}")

    # Support
    if targ_sx_sup >= targ_sy_sup:
        print(f"{'Support':<15} | {'MAIN':<10} | {int(targ_sx_sup):<15} | {prov_sx_sup['text']}")
        print(f"{'Support':<15} | {'SEC':<10} | {int(targ_sy_sup):<15} | {prov_sy_sup['text']}")
    else:
        print(f"{'Support':<15} | {'MAIN':<10} | {int(targ_sy_sup):<15} | {prov_sy_sup['text']}")
        print(f"{'Support':<15} | {'SEC':<10} | {int(targ_sx_sup):<15} | {prov_sx_sup['text']}")

    # --- 5. DEFLECTION CHECK ---
    print("\n--- CHECKS ---")

    # Deflection
    check_val = max(req_sx, As_min)
    deflection = check_deflection(Lx, dx, fck, check_val, prov_sx['area_prov'], panel_type_index)

    print(f"1. DEFLECTION (L/d): {deflection['status']}")
    print(f"   Actual: {deflection['actual']}  |  Allowable: {deflection['allowable']}")

    # Shear Check
    # We use the provided steel at the support (Main Support Steel) for shear resistance
    # Typically we check the critical shear, which usually aligns with the Short Span support reaction.
    shear_steel = prov_sx_sup['area_prov'] if targ_sx_sup > targ_sy_sup else prov_sy_sup['area_prov']

    shear = check_shear(n, Lx, dx, fck, shear_steel, panel_type_index)

    print(f"2. SHEAR (V_Ed vs V_Rd,c): {shear['status']}")
    print(f"   Design Shear (V_Ed): {shear['V_Ed']} kN")
    print(f"   Capacity (V_Rd,c):   {shear['V_Rdc']} kN")
    print(f"   Utilization:         {int(shear['utilization']*100)}%")

    print(f"\n{'='*60}")

# ==========================================
# PART 4: TEST RUN
# ==========================================
# Example: 3x5m, Interior Panel
run_design(Lx=3000, Ly=5000, h=150, fck=25, fyk=460, cover=25, Gk=6.45, Qk=1.5, bar_dia=12, panel_type_index=0)